/-
Copyright (c) 2022 Justin Thomas. All rights reserved.
Released under Apache 2.0 license as described in the file LICENSE.
Authors: Justin Thomas
-/
import data.polynomial
import data.polynomial.ring_division
import ring_theory.principal_ideal_domain
import algebra.module.linear_map
import field_theory.minpoly
import linear_algebra
import ring_theory.ideal.operations
import ring_theory.polynomial_algebra

/-!
# Annihilating Ideal

Given a commutative ring `R` and an `R`-algebra `A`
Every element `a : A` defines
an ideal `polynomial.annihilating_ideal a âŠ† R[X]`.
Simply put, this is the set of polynomials `p` where
the polynomial evaluation `p(a)` is 0.

## Special case where the ground ring is a field

In the special case that `R` is a field, we use the notation `R = ğ•œ`.
Here `ğ•œ[X]` is a PID, so there is a polynomial `g âˆˆ polynomial.annihilating_ideal a`
which generates the ideal. We show that if this generator is
chosen to be monic, then it is the minimal polynomial of `a`,
as defined in `field_theory.minpoly`.

## Special case: endomorphism algebra

Given an `R`-module `M` (`[add_comm_group M] [module R M]`)
there are some common specialiazations which may be more familiar.
* Example 1: `A = M â†’â‚—[R] M`, the endomorphism algebra of an `R`-module M.
* Example 2: `A = n Ã— n` matrices with entries in `R`.
-/

open_locale polynomial

namespace polynomial

section general_case

variables {R A : Type*} [comm_semiring R] [semiring A] [algebra R A]

variables (R)

/--
The informal notation `p(a)` stand for `polynomial.aeval a p`.
Again informally, the annihilating ideal of `a` is
`{ p âˆˆ R[x] | p(a) = 0 }`. This is an ideal in `R[X]`.
The formal definition uses the kernel of the aeval map. -/
noncomputable def annihilating_ideal (a : A) : ideal R[X] :=
ring_hom.ker (aeval a).to_ring_hom

variables {R}

/-- It is useful to refer to ideal membership sometimes
 and the annihilation condition other times -/
lemma mem_annihilating_ideal_iff_aeval_0 (a : A) (p : R[X]) :
  p âˆˆ annihilating_ideal R a â†” aeval a p = 0 :=
iff.rfl

end general_case

section field_case

variables {ğ•œ A : Type*} [field ğ•œ] [ring A] [algebra ğ•œ A]
variables (ğ•œ)

/-- Since `ğ•œ[x]` is a principal ideal domain there is a polynomial `g` such that
 `span ğ•œ {g} = annihilating_ideal a` -/
noncomputable def annihilating_ideal_generator (a : A) : ğ•œ[X] :=
submodule.is_principal.generator (annihilating_ideal ğ•œ a)

variables {ğ•œ}

section minpoly_generates

/-- We are working toward showing the generator of the annihilating ideal
in the field case is the minimal polynomial. We are going to use a uniqueness
theorem of the minimal polynomial. This is the first condition: it must annihilate
the original element `a : A`. -/
lemma annihilating_ideal_generator_aeval_0 (a : A) :
  aeval a (annihilating_ideal_generator ğ•œ a) = 0 :=
begin
  rw annihilating_ideal_generator,
  have gen_member := submodule.is_principal.generator_mem (annihilating_ideal ğ•œ a),
  exact (ring_hom.mem_ker (polynomial.aeval a).to_ring_hom).1 gen_member,
end

/-- This is a stepping stone to show the generator has minimal degree -/
lemma mem_iff_generator_dvd (a : A) (p : ğ•œ[X]) :
  p âˆˆ annihilating_ideal ğ•œ a â†” annihilating_ideal_generator ğ•œ a âˆ£ p :=
submodule.is_principal.mem_iff_generator_dvd (annihilating_ideal ğ•œ a)

/-- The generator of the annihilating ideal has minimal degree among
 the non-zero members of the annihilating ideal -/
lemma degree_annihilating_ideal_generator_le_of_mem (a : A) (p : ğ•œ[X])
  (hp : p âˆˆ annihilating_ideal ğ•œ a) (hpn0 : p â‰  0) :
  degree (annihilating_ideal_generator ğ•œ a) â‰¤ degree p :=
degree_le_of_dvd ((mem_iff_generator_dvd a p).1 hp) hpn0

/-- This is what we have been building to:
The monic generator of the annihilating ideal is the minimal polynomial. -/
lemma minpoly_eq_monic_annihilating_ideal_generator (a : A)
  (h : (annihilating_ideal_generator ğ•œ a).monic) :
  annihilating_ideal_generator ğ•œ a = minpoly ğ•œ a :=
begin
  /- 3 conditions for a poly being the minpoly -/
  apply minpoly.unique,
  /- 1st condition: the poly is monic -/
  { apply h, },
  /- 2nd condition: the poly annihilates a -/
  { apply annihilating_ideal_generator_aeval_0, },
  /- 3rd condition: the poly has minimal degree among annihilators of a -/
  { intros q hqm heval,
    apply degree_annihilating_ideal_generator_le_of_mem a q _ _,
    exact (mem_annihilating_ideal_iff_aeval_0 a q).2 heval,
    exact monic.ne_zero hqm, }
end

end minpoly_generates

/- Other simple facts about the annihilating ideal -/

/-- If the annihilating ideal is generated by zero, then every member is 0 -/
lemma eq_zero_of_mem_eq_zero (a : A) (p : ğ•œ[X])
  (hp : p âˆˆ annihilating_ideal ğ•œ a) (hu0 : annihilating_ideal_generator ğ•œ a = 0) :
  p = 0 :=
begin
  rwa [mem_iff_generator_dvd, hu0, zero_dvd_iff] at hp,
end

end field_case

end polynomial
